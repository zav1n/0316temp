# **最后更新：2020.4.27**

### 统用判断的类型判断有4种（！必须熟练这些类型判断）
+ 1.object.prototype.tostring.call(x)  ！必须掌握
  - 缺点
  - 缺点是效率慢，再也没有其他缺点

+ 2.typeof      一般判断基本数据类型
  - typeof 返回值有：（后面2个可以不用了解，看看就好）
  - Undefined "undefined"
  - Null  "object" (见下文)
  - Boolean "boolean"
  - Number  "number"
  - BigInt  "bigint"
  - String  "string"
  - Symbol (ECMAScript 2015 新增) "symbol"
  - Function "function"
  - 其他任何对象  "object"
  - 宿主对象（由 JS 环境提供） 取决于具体实现
  https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof

+ 3.instanceof  表明x实例是否是由X工厂构造的  返回布尔类型  判断最近类型是什么
 - 缺点

   - 1.不能判断基本数据类型

   - 2.不能判断最终的类型

+ 4.constructor （ES6的关键字，不是保留字） 返回布尔类型  表示该实例是哪个（最终）工厂构造  用法： x.constructor === X
- 缺点

  - 1.不能判断基本数据类型

  - 2.需要自定义类需要手动指定constructor

### const 声明变量（了解一下  同let 和var）
mdn介绍：
+ 常量是块级作用域，很像使用 let 语句定义的变量。常量的值不能通过重新赋值来改变，并且不能重新声明。

+ 实例  

  ```
  const number = 42;
  try {
    number = 99;
  } catch(err) {
    console.log(err);
    // expected output: TypeError: invalid assignment to const ‘number'
    // Note - error messages will vary depending on browser
  }
  console.log(number)    // 输出: 42
  ```

####for...in
推荐在循环对象属性的时候，使用for...in  循环的是key

+ mdn介绍：语句以任意顺序遍历一个对象的除Symbol以外的可枚举属性。

+ 语法
for (variable in object)
  statement

+ 为什么用for ... in?
  
- for ... in是为遍历对象属性而构建的，不建议与数组一起使用，数组可以用Array.prototype.forEach()
  
+ 实例1

```
  var obj = {a:1, b:2, c:3};
for (var prop in obj) {
  console.log("obj." + prop + " = " + obj[prop]);
  }
  // Output:
  // "obj.a = 1"
  // "obj.b = 2"
  // "obj.c = 3"
```

  https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in


####for...of
+ 在遍历数组的时候的时候使用for...of    循环的是value

+ mdn介绍：语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句

+ 语法：for (variable of iterable) {
    //statements
}
    
+ or...of不能循环普通的对象，需要通过和Object.keys()搭配使用

+ 简单实例

  ```
  const array1 = ['a', 'b', 'c'];
  
  for (const element of array1) {
    console.log(element);
  }
  // 输出: "a"
  // 输出: "b"
  // 输出: "c"
  ```

+ 实例 迭代Array

  ```
  let arr = [10, 20, 30];
  for (let value of arr) {
      value += 1;
      console.log(value);
  }
  // 11
  // 21
  // 31
  ```

  

+ 实例 迭代string

  ```
  let str = "boo";
  for (let value of str) {
    console.-log(value);
  }
  // "b"
  // "o"
  // "o"
  ```

  

### for...of与for...in的区别
+ 无论是for...in还是for...of语句都是迭代一些东西。它们之间的主要区别在于它们的迭代方式。
+ for...in 语句以任意顺序迭代对象的可枚举属性。
+ for...of 语句遍历可迭代对象定义要迭代的数据。

  - 以下示例显示了与Array一起使用时，for...of循环和for...in循环之间的区别。
//请前往MDN查看
https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of


### Array.prototype.flat()
mdn介绍
+ flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。

+ 语法 var newArray = arr.flat([depth])
  
- depth 可选 指定要提取嵌套数组的结构深度，默认值为 1。
  
+ 实例 扁平化嵌套数组

  ```
  var arr1 = [1, 2, [3, 4]];
  arr1.flat(); 
  // [1, 2, 3, 4]
  
  var arr2 = [1, 2, [3, 4, [5, 6]]];
  arr2.flat();
  // [1, 2, 3, 4, [5, 6]]
  
  var arr3 = [1, 2, [3, 4, [5, 6]]];
  arr3.flat(2);
  // [1, 2, 3, 4, 5, 6]
  
  //使用 Infinity，可展开任意深度的嵌套数组
  var arr4 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]];
  arr4.flat(Infinity);
  // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
  ```

  

+ 实例 flat() 方法会移除数组中的空项

  ```
  var arr4 = [1, 2, , 4, 5];
  arr4.flat();
  // [1, 2, 4, 5]
  ```

  

+ 总结，与forEach不一样的是，forEach使用回调函数后不会显示空字符或修改，而flat会移除，将flat获取到的值重新合并为一个新数组返回。
  https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat

### Array.isArray()
mdn介绍
+ Array.isArray() 用于确定传递的值是否是一个 Array。

+ 语法：Array.isArray(obj)  参数obj，你想要检测的值

+ 简单实例

  ```
  Array.isArray([1, 2, 3]); 
  // true
  Array.isArray({foo: 123}); 
  // false
  Array.isArray("foobar"); 
  // false
  Array.isArray(undefined); 
  // false
  ```

  

+ 进阶了解，简单实例2

  ```
  // 下面的函数调用都返回 true
  Array.isArray([]);
  Array.isArray([1]);
  Array.isArray(new Array());
  Array.isArray(new Array('a', 'b', 'c', 'd'))
  // 鲜为人知的事实：其实 Array.prototype 也是一个数组。
  Array.isArray(Array.prototype); 
  ```

  

+ 下面的函数调用都返回 false

  ```
  Array.isArray();
  Array.isArray({});
  Array.isArray(null);
  Array.isArray(undefined);
  Array.isArray(17);
  Array.isArray('Array');
  Array.isArray(true);
  Array.isArray(false);
  Array.isArray(new Uint8Array(32))
  Array.isArray({ __proto__: Array.prototype });
  ```

  https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray


### Array.from()
mdn介绍
+ Array.from() 方法从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。

+ 语法  Array.from(arrayLike[, mapFn[, thisArg]])  

+ **参数**

  - `arrayLike`想要转换成数组的伪数组对象或可迭代对象。
  - `mapFn` 可选    如果指定了该参数，新数组中的每个元素会执行该回调函数。
  - `thisArg` 可选    可选参数，执行回调函数 `mapFn` 时 `this` 对象。
  - **返回值**   一个新的数组实例。

+ 简单实例

  ```
  console.log(Array.from('foo'));
  // expected output: Array ["f", "o", "o"]
  console.log(Array.from([1, 2, 3], x => x + x));
  // expected output: Array [2, 4, 6]
  ```

+ 实例1 在 Array.from 中使用箭头函数

  ```js
  Array.from([1, 2, 3], x => x + x);
  // [2, 4, 6]
  ```

+ 实例2  老师讲解

  ```js
  //arrayLike 类数组对象(真数组)
  //mapFn 遍历的回调函数
  //e		i
  let arr = ["北京", "深圳", "上海"]
  Array.from(arr, function (e, i) {
  console.log(e, i)
  })
  //
  ```

+ 实例3   老师讲解

  ```HTML
  <ul id="container">
     <li></li>
     <li></li>
     <li></li>
  </ul>
  <script>
     let oUl = document.getElementById("container")
     //HTMLCollection
     let aLi = oUl.getElementsByTagName("li")
     //1. 将aLi的数据类型 强制转换成 Array 类型
     //2. 遍历aLi这个数据
     Array.from(aLi, (*e*) *=>* {
     e.style.backgroundColor = "pink"
     })
  </script>
  ```



###Array.prototype.forEach()

mdn介绍

forEach() 方法对数组的每个元素执行一次给定的函数。

语法：arr.forEach(callback(currentValue [, index [, array]])[, thisArg])

注意： 除了抛出异常以外，没有办法中止或跳出 forEach() 循环。如果你需要中止或跳出循环，forEach() 方法不是应当使用的工具。

- 若要跳出循环，请查看mdn

参数

- `callback`为数组中每个元素执行的函数，该函数接收一至三个参数：
- `currentValue`数组中正在处理的当前元素。
- `index` 可选   数组中正在处理的当前元素的索引。
- `array` 可选  `forEach()` 方法正在操作的数组。
- `thisArg` 可选  可选参数。当执行回调函数 `callback` 时，用作 `this` 的值。
- **返回值**   [`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)。
- 描述请见MDN

- 简单实例

```js
const array1 = ['a', 'b', 'c'];
array1.forEach(element => console.log(element));
// a b c
```



- 实例：空缺的数组单元未被函数回调或做任何处理

```js
const arraySparse = [1,3,,7];
let numCallbackRuns = 0;
arraySparse.forEach(function(element){
console.log(element);
numCallbackRuns++;
});
console.log("numCallbackRuns: ", numCallbackRuns);
// 1
// 3
// 7
// numCallbackRuns: 3
```

- 实例2   使用 `thisArg`

举个勉强的例子，按照每个数组中的元素值，更新一个对象的属性：

```js
function Counter() {
  this.sum = 0;
  this.count = 0;
}
Counter.prototype.add = function(array) {
  array.forEach(function(entry) {
    this.sum += entry;
    ++this.count;
  }, this);
  // ^---- Note
};
const obj = new Counter();
obj.add([2, 5, 9]);
obj.count;
// 3 === (1 + 1 + 1)
obj.sum;
// 16 === (2 + 5 + 9)
```

- 实例：将for循环转换为forEach

```js
const items = ['item1', 'item2', 'item3'];
const copy = [];
// for写法
for (let i=0; i<items.length; i++) {
copy.push(items[i]);
}
//forEach写法
items.forEach(function(item){
copy.push(item);
})
```



- 实例：forEach扁平化数组

```js
function flatten(arr) {
const result = [];
arr.forEach((i) => {
  if (Array.isArray(i))
    result.push(...flatten(i));
  else
    result.push(i);
})
return result;
}
//定义数组
const problem = [1, 2, 3, [4, 5, [6, 7], 8, 9]];
//调用
flatten(problem);
// [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

- 老师讲解  实例

```js
//element 当前被遍历的元素值
//index 当前被遍历的元素下标
//array 源数据

let arr = ["北京", "深圳", "上海"]
    //forEach 不会提供返回值
arr.forEach(function(e, i, a) {
        console.log(e, i, a)
    })
    //北京 0 [ '北京', '深圳', '上海' ]
    //深圳 1 [ '北京', '深圳', '上海' ]
    //上海 2 [ '北京', '深圳', '上海' ]
```

https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach

### Array.prototype.map()

+ map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一次提供的函数后的返回值。

+ 语法   

  - ```js
    var new_array = arr.map(function callback(currentValue[, index[, array]]) {
     // Return element for new_array 
    }[, thisArg])
    ```

+ **参数**

  - `callback`	生成新数组元素的函数，使用三个参数： 
  - `currentValue`  `callback` 数组中正在处理的当前元素。
  - `index`可选   `callback` 数组中正在处理的当前元素的索引。
  - `array`可选    `map` 方法调用的数组。
  - `thisArg`可选     执行 `callback` 函数时值被用作`this`。
  - **返回值**     回调函数的结果组成了新数组的每一个元素。

+ 实例

  ```js
  const array1 = [1, 4, 9, 16];
  // pass a function to map
  const map1 = array1.map(x => x * 2);
  console.log(map1);
  // expected output: Array [2, 8, 18, 32]
  ```

+ 实例   一般的`map` 方法

  下面的例子演示如何在一个 [`String`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/String) 上使用 map 方法获取字符串中每个字符所对应的 ASCII 码组成的数组：

  ```js
  var map = Array.prototype.map
  var a = map.call("Hello World", function(x) { 
    return x.charCodeAt(0); 
  })
  // a的值为[72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100]
  ```

+ 实例2  求数组中每个元素的平方根

  下面的代码创建了一个新数组，值为原数组中对应数字的平方根。

  ```js
  var numbers = [1, 4, 9];
  var roots = numbers.map(Math.sqrt);
  // roots的值为[1, 2, 3], numbers的值仍为[1, 4, 9]
  ```

+ 实例3 使用 map 重新格式化数组中的对象

  以下代码使用一个包含对象的数组来重新创建一个格式化后的数组。

  ```js
  var kvArray = [{key: 1, value: 10}, 
                 {key: 2, value: 20}, 
                 {key: 3, value: 30}];
  
  var reformattedArray = kvArray.map(function(obj) { 
     var rObj = {};
     rObj[obj.key] = obj.value;
     return rObj;
  });
  // reformattedArray 数组为： [{1: 10}, {2: 20}, {3: 30}], 
  // kvArray 数组未被修改: 
  // [{key: 1, value: 10}, 
  //  {key: 2, value: 20}, 
  //  {key: 3, value: 30}]
  ```

+ 实例3  使用一个包含一个参数的函数来mapping(构建)一个数字数组

  下面的代码表示了当函数需要一个参数时map的工作方式。当map循环遍历原始数组时，这个参数会自动被分配成数组中对应的每个元素。

  ```js
  var numbers = [1, 4, 9];
  var doubles = numbers.map(function(num) {
    return num * 2;
  });
  
  // doubles数组的值为： [2, 8, 18]
  // numbers数组未被修改： [1, 4, 9]
  ```

+ 实例4   Mapping 含 undefined的数组

  当返回undefined 或没有返回任何内容时:

  ```js
  var arr = [1, 2, 3, 4];
  var newArr = arr.map(function(num, index) {
    if (index < 3) {
      return num;
    }
  });
  console.log(newArr);
  //从下标开始算 [0],所以结果等于 [ 1, 2, 3, undefined ]
  // 数组仍然是 [1, 2, 3, 4]
  ```

+ 实例5  老师讲解

  ```js
  let strArr = ["第一", "第二", "第三"];
  let result = strArr.map(e => {
    return e + "赢了"
   })
   console.log(result) //[ '第一赢了', '第二赢了', '第三赢了' ]
  let arr2 = [1, 2, 3, 4]
  let newArr = arr2.map(e => e * e)
   console.log(newArr) //[1, 4, 9, 16]
  ```

### Array.prototype.filter()

+ filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 

+ 方法   var newArray = arr.filter(callback(element[, index[, array]])[, thisArg])

+ 参数    

  - `callback`用来测试数组的每个元素的函数。返回 `true` 表示该元素通过测试，保留该元素，`false` 则不保留。它接受以下三个参数：
  - `element`数组中当前正在处理的元素。
  - `index`可选  正在处理的元素在数组中的索引。
  - `array`可选    调用了 `filter` 的数组本身。
  - `thisArg`可选    执行 `callback` 时，用于 `this` 的值。
  - **返回值**    一个新的、由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组。

+ 实例  

  ```js
  const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];
  const result = words.filter(word => word.length > 6);
  console.log(result);
  // expected output: Array ["exuberant", "destruction", "present"]
  ```

+ 实例1   筛选排除所有较小的值

  下例使用 `filter` 创建了一个新数组，该数组的元素由原数组中值大于 10 的元素组成。

  ```js
  function isBigEnough(element) {
    return element >= 10;
  }
  var filtered = [12, 5, 8, 130, 44].filter(isBigEnough);
  // filtered is [12, 130, 44] 
  ```

+ 实例2   过滤 JSON 中的无效条目

   以下示例使用 `filter()` 创建具有非零 `id` 的元素的 json。

  ```js
  var arr = [
    { id: 15 },
    { id: -1 },
    { id: 0 },
    { id: 3 },
    { id: 12.2 },
    { },
    { id: null },
    { id: NaN },
    { id: 'undefined' }
  ];
  
  var invalidEntries = 0;
  
  function isNumber(obj) {
    return obj !== undefined && typeof(obj) === 'number' && !isNaN(obj);
  }
  
  function filterByID(item) {
    if (isNumber(item.id) && item.id !== 0) {
      return true;
    } 
    invalidEntries++;
    return false; 
  }
  
  var arrByID = arr.filter(filterByID);
  
  console.log('Filtered Array\n', arrByID); 
  // Filtered Array
  // [{ id: 15 }, { id: -1 }, { id: 3 }, { id: 12.2 }]
  
  console.log('Number of Invalid Entries = ', invalidEntries); 
  // Number of Invalid Entries = 5
  ```

+ 实例3  在数组中搜索  

  下例使用 `filter()` 根据搜索条件来过滤数组内容。

  ```js
  var fruits = ['apple', 'banana', 'grapes', 'mango', 'orange'];
  function filterItems(query) {
      return fruits.filter(function(e) {
          return e.toLowerCase().indexOf(query.toLowerCase()) > -1;
      })
  }
  console.log(filterItems('ap')); // ['apple', 'grapes']
  console.log(filterItems('an')); // ['banana', 'mango', 'orange']
  ```

+ 实例4   老师讲解

  ```js
  //保留所有的奇数 [1, 3, 5, 7, 9]
  let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
  //遍历所有的元素 当该元素的返回值 是真的时候 就保留 是假的时候就不保留
  let newArr = arr.filter(e => e % 2 === 1)
  let newArr = arr.filter(function (e) {
    if (e % 2 === 0) {
      //2 4 6 8 10
      return false
    } else {
      //1 3 5 7 9
      return true
    }
  })
  console.log(newArr)
  ```


### Array.prototype.sort()

+ sort() 方法用[原地算法](https://en.wikipedia.org/wiki/In-place_algorithm)对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的

  由于它取决于具体实现，因此无法保证排序的**时间**和**空间**复杂性。

+ 语法  arr.sort([compareFunction])

+ 参数

  - `compareFunction`可选

    用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的各个字符的Unicode位点进行排序。   

    `firstEl`  第一个用于比较的元素。 

     `secondEl`  第二个用于比较的元素

  - 返回值

    排序后的数组。请注意，数组已原地排序，并且不进行复制。

+ 实例`sort` 方法可以使用函数表达式方便地书写

  ```js
  var numbers = [4, 2, 5, 1, 3];
  numbers.sort(function(a, b) {
    return a - b;
  });
  console.log(numbers);
  
  也可以写成：
  var numbers = [4, 2, 5, 1, 3]; 
  numbers.sort((a, b) => a - b); 
  console.log(numbers);
  
  // [1, 2, 3, 4, 5]
  ```

+ 实例2   对象可以按照某个属性排序：

  ```js
  var items = [
    { name: 'Edward', value: 21 },
    { name: 'And', value: 45 },
    { name: 'The', value: -12 },
    { name: 'Magnetic' },
    { name: 'Zeros', value: 37 }
  ];
  // 按年龄排序
  items.sort(function(a, b) {
      return (*a*.value - *b*.value)
  });
  console.log(items);
  
  // 按英文名字排序
  
  items.sort(function(a, b) {
    var nameA = a.name.toUpperCase(); // ignore upper and lowercase
    var nameB = b.name.toUpperCase(); // ignore upper and lowercase
  
    if (nameA < nameB) {
     return -1;
    }
  
    if (nameA > nameB) {
     return 1;
    }
  
    // names must be equal
    return 0;
  
  });
  
  console.log(items);
  ```

+ 老师讲解

  ```js
  //sort 方法的本质 是将 所有的元素 转换成 字符串 再根据UTF-16进行排序
  let arr = ["apple", "cherry", "AAA", "zzz", "banana", 1, 2, 3]
  let newArr = arr.sort(); //1, 2, 3, AAA, apple, banana, cherry, zzz
  console.log(newArr);
  
  //在正常的字符串比较的时候是没有任何问题的 但是在纯数字的理解上 计算机和人类产生了冲突
  //需要为sort提供一个回调函数 主动的提供自定义的排序方法
  //在这个回调函数中 又规定两个 回调参数
  //第一个参数 代表的是当前值
  //第二个参数 代表的是下一个值
  //再为这个回调函数提供一个返回值
  //如果返回值是负数的话 那么前后两个参数 就会原地发生交换 否则不交换
  let arr2 = [1, 11, 2, 22];
  
  console.log(arr2.sort(function (a, b) {
    if (a < b) {
      return -1
    } else if (a === b) {
      return 0
    } else {
      return 1
    }
    // return a - b
  })); //1, 11,2, 22
  arr2.sort((a, b) => a - b)
  ```

### Array.prototype.join()

+ join() 方法将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。

+ 语法     arr.join([separator])

+ 参数    

  - `separator` 可选      指定一个字符串来分隔数组的每个元素。如果需要，将分隔符转换为字符串。如果缺省该值，数组元素用逗号（`,`）分隔。如果`separator`是空字符串(`""`)，则所有元素之间都没有任何字符。
  - 返回值     一个所有数组元素连接的字符串。如果 `arr.length` 为0，则返回空字符串。

+ 实例

  ```js
  var a = ['Wind', 'Rain', 'Fire'];
  var myVar1 = a.join();      // myVar1的值变为"Wind,Rain,Fire"
  var myVar2 = a.join(', ');  // myVar2的值变为"Wind, Rain, Fire"
  var myVar3 = a.join(' + '); // myVar3的值变为"Wind + Rain + Fire"
  var myVar4 = a.join('');    // myVar4的值变为"WindRainFire"
  ```

### Array.prototype.indexOf()

mdn介绍

+ indexOf() 方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。

+ 语法 arr.indexOf(searchElement[, fromIndex])

  - searchElement    要查找的元素

  - fromIndex            可选

    开始查找的位置。如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回-1。如果参数中提供的索引值是一个负值，则将其作为数组末尾的一个抵消，即-1表示从最后一个元素开始查找，-2表示从倒数第二个元素开始查找 ，以此类推。  注意：如果参数中提供的索引值是一个负值，并不改变其查找顺序，查找顺序仍然是从前向后查询数组。如果抵消后的索引值仍小于0，则整个数组都将会被查询。其默认值为0.

  - **返回值**   首个被找到的元素在数组中的索引位置; 若没有找到则返回 -1

+ 实例

  ```
  let str = "abcdbacbcd";
  console.log(str.indexOf("b")) //1
  console.log(str.indexOf("bcd")) //1 第一个匹配的头部元素的下标
  ```

  

+ 实例1 以下例子使用`indexOf方法确定多个值在数组中的位置。`

  ```js
  var array = [2, 5, 9];
  array.indexOf(2);     // 0
  array.indexOf(7);     // -1
  array.indexOf(9, 2);  // 2
  array.indexOf(2, -1); // -1
  array.indexOf(2, -3); // 0
  ```

+ 实例2   找出指定元素出现的所有位置

  ```js
  var indices = [];
  var array = ['a', 'b', 'a', 'c', 'a', 'd'];
  var element = 'a';
  var idx = array.indexOf(element);
  while (idx != -1) {
    indices.push(idx);
    idx = array.indexOf(element, idx + 1);
  }
  console.log(indices);
  // [0, 2, 4]
  ```

+ 实例3

  ```
  let arr = ["A", "B", "B", "B", "D", "C", "D", "B"]
  
  // 1.1查询有没有 char 有就返回 true 没有就返回 false
  // arr.indexOf(searchElement[, fromIndex])
  // arr.indexOf()
  // arr.lastIndexOf() 不会改变原来数组的下标，只是从后面返回
  
  //写法一  查找B有没有在数组里面
  
  let Search_B = arr.indexOf("B")
      if(Search_B != -1 ){
          console.log(true)
          }else{
          console.log(false)
      }
  
  //写法一用函数写，想查找那个值就直接在函数的参数输入想要查询的值
  
  function Search(*v*){
      Char = arr.indexOf(*v*)
      if(Char != -1 ){
          console.log("写法二 ： "+true)
          }else{
          console.log("写法二 ： "+false)
      }
  }
  
  //输入你想找的值，如果没有控制台显示false，否则显示true  这里默认查找K，K不在数组里面，所以控制台显示false
  Search("K")
  
  //---------------------------------------------------------
  
  //arr.lastIndexOf()写法  查找有没有A
  
  let Search_A = arr.lastIndexOf("A")
  if(Search_A != -1 ) {
      console.log("lastIndexOf()写法："+true)
      }else{
      console.log("lastIndexOf()写法："+false)
  }
  ```

### String.prototype.indexOf()

https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf

### Object.assign()

浅复制,一层赋值,slice方法也是

mdn介绍
+ Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。

+ 语法 Object.assign(target, ...sources)  target 目标对象。sources 源对象。

+ 实例 复制一个对象

  ```
  const obj = { a: 1 };
  const copy = Object.assign({}, obj);
  console.log(copy); // { a: 1 }
  ```

  

+ 实例 合并对象

  ```
  const o1 = { a: 1 };
  const o2 = { b: 2 };
  const o3 = { c: 3 };
  const obj = Object.assign(o1, o2, o3);
  console.log(obj); // { a: 1, b: 2, c: 3 }
  console.log(o1);  // { a: 1, b: 2, c: 3 }, 注意目标对象自身也会改变。
  ```

  https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign


### String.prototype.slice()  切割
mdn语法
+ slice() 方法提取某个字符串的一部分，并返回一个新的字符串，且不会改动原字符串。
+ 语法 str.slice(beginIndex[, endIndex])  
- beginIndex
- 以下标 0 开始提取原字符串中的字符。如果值为负数，会从字符串最后面开始算
- endIndex
- 可选。以下标 0 结束提取字符串。如果省略该参数，slice() 会一直提取到字符串末尾。可以为为负数
+ 简单实例

  ```
  let str1 = 'The morning is upon us.', // str1 的长度 length 是 23。
  let str2 = str1.slice(1, 8),
  let str3 = str1.slice(4, -2),
  let str4 = str1.slice(12),
  let str5 = str1.slice(30);
  console.log(str2); // 输出：he morn
  console.log(str3); // 输出：morning is upon u
  console.log(str4); // 输出：is upon us.
  console.log(str5); // 输出：""
  ```

  

+ 实例 给 slice() 传入负值索引

  ```
  let str = 'The morning is upon us.';
  str.slice(-3);     // 返回 'us.'
  str.slice(-3, -1); // 返回 'us'
  str.slice(0, -1);  // 返回 'The morning is upon us'
  ```

  

#### String.prototype.slice()和assign()的不同
slice截取不会改变原来的对象，而assign合并后会改变原来的对象

Array也有slice（）方法  

使用方法和String.prototype.slice()相似，相似度高

### String.prototype.substring()
mdn介绍
+ substring() 方法返回一个字符串在开始索引到结束索引之间的一个子集, 或从开始索引直到字符串的末尾的一个子集。
+ 语法 str.substring(indexStart[, indexEnd]) 
 - indexStart
 - 需要截取的第一个字符的索引，该索引位置的字符作为返回的字符串的首字母。
 - indexEnd
 - 可选。一个 0 到字符串长度之间的整数，以该数字为索引的字符不包含在截取的字符串内。
 - 返回值
 - 包含给定字符串的指定部分的新字符串。
  + 简单实例
    
  ```
  	var anyString = "Mozilla";
    // 输出 "Moz"
    console.log(anyString.substring(0,3));
    console.log(anyString.substring(3,0));
    console.log(anyString.substring(3,-3));
    console.log(anyString.substring(3,NaN));
    console.log(anyString.substring(-2,3));
    console.log(anyString.substring(NaN,3));
    // 输出 "lla"
    console.log(anyString.substring(4,7));
    console.log(anyString.substring(7,4));
    // 输出 ""
    console.log(anyString.substring(4,4));
    // 输出 "Mozill"
    console.log(anyString.substring(0,6));
    // 输出 "Mozilla"
  console.log(anyString.substring(0,7));
      console.log(anyString.substring(0,10));
  ```


​    
  + 实例 运用 length 属性来使用 substring()
    
  ```
  // 显示 'illa' 最后4个字符
    var str = 'Mozilla';
    var strShow = str.substring(str.length - 4);
    console.log(strShow);
  
    // 显示 'zilla' 最后5个字符
    var str = 'Mozilla';
    var strShow = str.substring(str.length - 5);
    console.log(strShow);
  ```

  https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/substring


#### substring()和slice（）的区别 （截取）
```
var anyString = "Mozilla";
console.log(anyString.substring(1,2));// o
console.log(anyString.slice(1,2));// o

console.log(anyString.substring(-1));// Mozilla
console.log(anyString.slice(-1));// a

console.log(anyString.substring(-2));// Mozilla
console.log(anyString.slice(-2));// la

console.log(anyString.substring(-2,2));// la
console.log(anyString.slice(-2,2));//  Mo
```



### String.prototype.split() （切）
mdn介绍
+ split() 方法使用指定的分隔符字符串将一个String对象分割成子字符串数组，以一个指定的分割字串来决定每个拆分的位置。 

+ 语法 str.split([separator[, limit]])
  - 参数
  - separator
    指定表示每个拆分应发生的点的字符串。separator 可以是一个字符串或正则表达式。 如果纯文本分隔符包含多个字符，则必须  找到整个字符串来表示分割点。如果在str中省略或不出现分隔符，则返回的数组包含一个由整个字符串组成的元素。如果分隔符为空字符串，则将str原字符串中每个字符的数组形式返回。
  - limit
    一个整数，限定返回的分割片段数量。当提供此参数时，split 方法会在指定分隔符的每次出现时分割该字符串，但在限制条目已放入数组时停止。如果在达到指定限制之前达到字符串的末尾，它可能仍然包含少于限制的条目。新数组中不返回剩下的文本。
  - 返回值
    返回源字符串以分隔符出现位置分隔而成的一个 Array 
  
+ 简单实例

  ```
  const str = 'The quick brown fox jumps over the lazy dog.';
  
  const words = str.split(' ');
  console.log(words[3]);
  // expected output: "fox"
  
  const chars = str.split('');
  console.log(chars[8]);
  // expected output: "k"
  
  const strCopy = str.split();
  console.log(strCopy);
  // expected output: Array ["The quick brown fox jumps over the lazy dog."]
  ```

  

+ 实例2

  ```js
  function splitString(stringToSplit, separator) {
    var arrayOfStrings = stringToSplit.split(separator);
    console.log('原来的字符串: "' + stringToSplit + '"');
    console.log('切割符号是: "' + separator + '"');
    console.log("有几个元素：" + arrayOfStrings.length + " elements: ");
  
    for (var i=0; i < arrayOfStrings.length; i++)
      console.log(arrayOfStrings[i] + " / ");
  
  console.log('=================分段====================');
  
  }
  
  var stringTxt = "Oh brave new world that has such people in it.";
  var stringMonth = "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec";
  
  var space = " ";
  var comma = ",";
  
  splitString(stringTxt, space);//输出1
  splitString(stringTxt);//输出2
  splitString(stringMonth, comma);//输出3
  
  **输出1**：原来的字符串: "Oh brave new world that has such people in it."
  切割符号是: " "
  有几个元素：10 elements: 
  Oh / brave / new / world / that / has / such / people / in / it. / 
  
  **输出2**：
  原来的字符串: "Oh brave new world that has such people in it."
  切割符号是: "undefined"
  有几个元素：1 elements: 
  
  Oh brave new world that has such people in it. / 
  
  **输出3**：
  原来的字符串: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec"
  切割符号是: ","
  有几个元素：12 elements: Jan / Feb / Mar / Apr / May / Jun / Jul / Aug / Sep / Oct / Nov / Dec / 
  ```


### Array.prototype.splice()

https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/splice



### String.prototype.includes()

mdn介绍
+ includes() 方法用于判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false。、
+ 语法 str.includes(searchString[, position])
- searchString
- 要在此字符串中搜索的字符串。
- position
- 可选。从当前字符串的哪个索引位置开始搜寻子字符串，默认值为0。
- 返回值
- 如果当前字符串包含被搜寻的字符串，就返回 true；否则返回 false。
注意的是，该方法判断目标字符串是否包含我要找的字符串的时候，会区分字母大小写
+ 实例 区分大小写

  ```
  'Blue Whale'.includes('blue'); // returns false
  ```

+ 实例2 

  ```
  var str = 'To be, or not to be, that is the question.';
  console.log(str.includes('To be'));       // true
  console.log(str.includes('question'));    // true
  console.log(str.includes('nonexistent')); // false
  console.log(str.includes('To be', 1));    // false
  console.log(str.includes('TO BE'));       // false
  ```

  https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/includes

### (push尾部添加N个)(pop尾部删除一个)(unshift头部添加)(shift头部删除)

#### Array.prototype.push()
+ push() 方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度。

+ 语法 arr.push(element1, ..., elementN)

+ 参数
  elementN被添加到数组末尾的元素。
  返回值：（后面2个可以不用了解，看看就好）当调用该方法时，新的 length 属性值将被返回。
  
+ 实例
  
  ```
  let animals = ['pigs', 'goats', 'sheep'];
  let count = animals.push('cows');
  console.log(count);//输出: 4
  console.log(animals);// 输出: ["pigs", "goats", "sheep", "cows"]
  animals.push('chickens', 'cats', 'dogs');
  console.log(animals);
  // 输出: ["pigs", "goats", "sheep", "cows", "chickens", "cats", "dogs"]
  ```
  
+ 实例2 将第二个数组融合进第一个数组,并且不修改原来的数组
  
  ```
  let num = ["a", "A"];
  let str = ['小a', '大a'];
  let newArr=[]
  newArr.push(...num,...str)//如果不想脱各自数组的括号[]就不用...
  console.log(newArr);
  ```

#### Array.prototype.pop()
+ pop()方法从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。

+ 语法 arr.pop()

+ 返回值 从数组中删除的元素(当数组为空时返回undefined)。

+ 实例
  
  ```
  let arr = ["aaa", "bbb", "ccc", "ddd"];
  let newArr = arr.pop();//把最后一个删了
  console.log(arr); //会修改原数组  ["aaa","bbb","ccc"]
  console.log(newArr); //ddd  获取删除的那个元素
  ```

####  Array.prototype.unshift()
+ unshift() 方法将一个或多个元素添加到数组的开头，并返回该数组的新长度(该方法修改原有数组)。

+ 语法 arr.unshift(element1, ..., elementN)

+ 参数
  - elementN
    要添加到数组开头的元素或多个元素。
  - 返回值
    当一个对象调用该方法时，返回其 length 属性值。
  
+ 实例
  
  - [ ] ```
    let arr = [1, 2];
    let newArr1 = arr.unshift(0); 
    console.log(arr); //[0,1,2]
    
    let arr = [1, 2];
    let newArr2 = arr.unshift(-2, -1); 
    console.log(arr);//[ -2, -1, 1, 2 ]
    
    let arr = [1, 2];
    let newArr3 = arr.unshift([-4, -3]); 
    console.log(arr);//[ [ -4, -3 ], 1, 2 ]
    
    let arr = [1, 2];
    let newArr4 = arr.unshift([-7, -6], [-5]); 
    console.log(arr);//[ [ -7, -6 ], [ -5 ], 1, 2 ]
    ```
  
  

#### Array.prototype.shift()

+ shift() 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。

+ 语法 arr.shift()

+ 返回值   从数组中删除的元素; 如果数组为空则返回undefined。

+ 实例
  
  ```
  let arr = ['aaa', 'bbb', 'ccc', 'ddd'];
  console.log('使用 shift 之前: ' + arr);// 使用 shift 之前: aaa,bbb,ccc,ddd
  let useShift = arr.shift(); 
  console.log('使用 shift 之后: ' + arr); //使用 shift 之后: bbb,ccc,ddd
  console.log('被删除的元素: ' + useShift); // 被删除的元素: aaa
  ```

### 正则用到的方法 match,test,search,exec,replace

//g: global 全局的   i: ignore 忽略大小写   m: mutiple 多行模式
其中最常用match和test

#### String.prototype.match()

  RegExp.prototype[@@match]()

- 语法 str.match(regexp)  

- 实例
  
  ```
  var str = 'For more information, see Chapter 3.4.5.1';
var re = /see (chapter \d+(\.\d)*)/i;
  var found = str.match(re);
  console.log(found);
  ```

#### RegExp.prototype.test()  

- test() 方法执行一个检索，用来查看正则表达式与指定的字符串是否匹配。返回 true 或 false。

- 语法 regexObj.test(str)

- 实例

  ```
  let str = 'hello world!';
  let result = /^hello/.test(str);
  console.log(result); // true
  ```

#### String.prototype.search()

- 语法 str.search(regexp)

- search() 方法执行正则表达式和 String 对象之间的一个搜索匹配。

- 实例

  ```
  let textStr = 'The quick brown fox jumps over the lazy dog. If the dog barked';
  // any character that is not a word character or whitespace
  const regex = /[^\w\s]/g;
  console.log(textStr.search(regex));//输出: 43
  console.log(textStr[textStr.search(regex)]);//输出: "."
  ```

#### RegExp.prototype.exec()

- exec() 方法在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 null。

- 语法 regexObj.exec(str)  

- 返回值
  如果匹配成功，exec() 方法返回一个数组（包含额外的属性 index 和 input，参见下方表格），并更新正则表达式对象的lastIndex 属性。完全匹配成功的文本将作为返回数组的第一项，从第二项起，后续每项都对应正则表达式内捕获括号里匹配成功的文本。
  如果匹配失败，exec() 方法返回 null，并将 lastIndex 重置为 0 。
  
- 实例
  
  ```
  let str = "abc ABC abc"
  let reg = /a/gi
  //g: global 全局的
  //i: ignore 忽略大小写
  //m: mutiple 多行模式
  //如果你要用exec那么正则必须有g
  console.log(reg.exec(str)) 
  //[ 'a', index: 0, input: 'abc ABC abc', groups: undefined ]
  ```

#### RegExp.prototype[@@replace]()

- [@@replace]() 方法会在一个字符串中用给定的替换器，替换所有符合正则模式的匹配项，并返回替换后的新字符串结果。用来替换的参数可以是一个字符串或是一个针对每次匹配的回调函数。

- 语法 regexp[Symbol.replace](str,newSubStr|function)

- 参数
  str正则替换的目标字符串。
  newSubStr (replacement)
  类型为 String 的替换器。支持大多数特殊的替换匹配模式； 见String.prototype.replace()页的Specifying a string as a parameter部分。
  function (replacement)
  生成新的子字符串的回调函数替换器
  返回值
  用替换器替换相应匹配项后的新字符串。
  
- 实例
  
  ```
  let str = "abcddcba";
console.log(str.replace("b", "*")) //a*cddcba
  //字符串 无论如何怎么操作和匹配 他总是懒汉模式
  console.log(str.replace(/b/, "*")) //a*cddcba
//正则表达式 默认也是懒汉模式 除非加入g标识符 才能变成饿汉模式
  console.log(str.replace(/b/g, "*")) //a*cddc*a
  ```
  
- 实例2
  
  ```
  let str2 = "1,2,3,4";
  let str3 = "巴拉啦,小魔仙,穆罕默德·本·阿卜杜拉·本·阿卜杜勒·穆塔利·本·哈希姆"
  let reg = /\d+/g
  let reg2 = /[\u4e00-\u9fa5·]+/g
  console.log(str2.replace(reg, (e) => e * e))
  console.log(str3.replace(reg2, (e) => e + "真可爱"))
  ```

### 函数的call、apply、bind

#### Function.prototype.call()

+ call()方法使用一个指定的 `this` 值和单独给出的一个或多个参数来调用一个函数。

+ 语法    function.call(thisArg, arg1, arg2, ...）   可以传多个参数

+ 参数

  - `thisArg`

    可选的。在 *`function`* 函数运行时使用的 `this` 值。请注意，`this`可能不是该方法看到的实际值：如果这个函数处于[非严格模式](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode)下，则指定为 `null` 或 `undefined` 时会自动替换为指向全局对象，原始值会被包装。

  - `arg1, arg2, ...`

    指定的参数列表。

    返回值

    使用调用者提供的 `this` 值和参数调用该函数的返回值。若该方法没有返回值，则返回 `undefined`。

+ 实例

  + ```
    function eat() {
    console.log(this.name + "在吃")
    }
    let obj1 = {
    name: "张三"
    }
    let obj2 = {
    name: "李四"
    }
    eat.call(obj1)
    eat.call(obj2)
    ```

  + 使用 `call` 方法调用匿名函数

    ```
    let animals = [
    { species: 'Lion', name: 'King' },
    { species: '狗', name: '柯基' }
    ];
    
    for (var i = 0; i < animals.length; i++) {
      (function(i) {
        this.print = function() {
          console.log('下标：' + i);
          console.log(this.species+ ': ' + this.name);
        }
        this.print();
      }).call(animals[i], i);
    }
    //输出为下标：0 Lion: King			下标：1 狗: 柯基
      //for遍历animals  i获取下标   匿名函数 (function(i){}).call(animals[i],i)
    ```

  + 使用 `call` 方法调用函数并且指定上下文的 '`this`'

    ```
    function amimals() {
      let reply = [this.animal, '睡', this.sleepDuration].join("");
      console.log(reply);
    }
    
    var obj = {
      animal: '猫', 
      sleepDuration: '12到16个小时'
    };
    
    amimals.call(obj);  //猫睡12到16个小时
    ```

  https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call

#### Function.prototype.apply()

+ **`apply()`** 方法调用一个具有给定`this`值的函数，以及作为一个数组（或[类似数组对象](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Indexed_collections#Working_with_array-like_objects)）提供的参数。

+ 语法     func.apply(thisArg, [argsArray])    注意！只有两个参数，第一个必填，第二个是一个数组，只有两个参数

+ 参数

  - `thisArg`

    必选的。在 *`func`* 函数运行时使用的 `this` 值。请注意，`this`可能不是该方法看到的实际值：如果这个函数处于[非严格模式](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode)下，则指定为 `null` 或 `undefined` 时会自动替换为指向全局对象，原始值会被包装。

  - `argsArray`

    可选的。一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 `func` 函数。如果该参数的值为 [`null`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null) 或 [`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。 

  - ###### 返回值

    ###### 调用有指定`**this**`值和参数的函数的结果。

+ 实例  用 `apply` 将数组添加到另一个数组

  - ```
    var array = ['a', 'b'];
    var elements = [0, 1, 2];
    array.push.apply(array, elements);
    console.info(array); // ["a", "b", 0, 1, 2]
    ```

+ 更多请查看MDN：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply

**注意：call()方法的作用和 apply() 方法类似，区别就是`call()`方法接受的是参数列表，而`apply()`方法接受的是一个参数数组。**

+ 实例 来自：4-8 / js14 / 14-call&apply&bind4.html 

  - ```
    <div id="div1">1</div>
    <div id="div2">2</div>
    
    let oDiv1 = document.querySelector("#div1")
    let oDiv2 = document.querySelector("#div2")
    let change = function (color, width, height) {
    this.style.backgroundColor = color
    this.style.width = width
    this.style.height = height
    }
    
    oDiv1.addEventListener("click", function () {
     	//apply 最多只有两个参数		thisArg		所有的形参形成一个数组
     	//call  正无穷个参数		   thisArg	 参数列表
     	//oDiv1 借用 window 的 change函数 令this指向 oDiv1
     	change.call(this, "pink", "100px", "100px") //this指向被改变的函数的调用
     	// change.apply(this, ["pink", "100px", "100px"]) //this指向被改变的函数的调用
    })
    ```

  oDiv1.addEventListener("click", function () {
   	//apply 最多只有两个参数		thisArg		所有的形参形成一个数组
   	//call  正无穷个参数		   thisArg	 参数列表
   	//oDiv1 借用 window 的 change函数 令this指向 oDiv1
   	change.call(this, "pink", "100px", "100px") //this指向被改变的函数的调用
   	// change.apply(this, ["pink", "100px", "100px"]) //this指向被改变的函数的调用
  })

#### Function.prototype.bind()

+ `**bind()**` 方法创建一个新的函数，在 `bind()` 被调用时，这个新函数的 `this` 被指定为 `bind()` 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。

+ ##### 语法  function.bind(thisArg[, arg1[, arg2[, ...]]])

+ ##### 参数

  - `thisArg`

    调用绑定函数时作为 `this` 参数传递给目标函数的值。 如果使用[`new`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new)运算符构造绑定函数，则忽略该值。当使用 `bind` 在 `setTimeout` 中创建一个函数（作为回调提供）时，作为 `thisArg` 传递的任何原始值都将转换为 `object`。如果 `bind` 函数的参数列表为空，执行作用域的 `this` 将被视为新函数的 `thisArg`。

  - `arg1, arg2, ...`

    当目标函数被调用时，被预置入绑定函数的参数列表中的参数。

  - ##### 返回值

    ##### 返回一个原函数的拷贝，并拥有指定的 **`this`** 值和初始参数

+ 实例 

  - ```
    let obj = {
      str: 42,
      getFn: function() {
      return this.str;
      }
    }
    
    let unboundGetFn = obj.getFn;
    console.log(unboundGetFn()); // 函数在全局范围内被调用
    // 输出: undefined
    
    let boundGetX = obj.getFn.bind(obj);
    console.log(boundGetX());
    // 输出: 42
    ```

### Number

```js
//NaN 在任何时候 都不等于另外一个NaN
        console.log(NaN === NaN)
        
console.log(null === null)//true
console.log(null == null)//true
console.log(undefined === undefined)//true
console.log(undefined == undefined)//true
//以下判断因为内存地址不一样所以都是false
console.log({} === {})//false
console.log({} == {})//false
console.log([] === [])//false
console.log([] == [])//false

let num1 = 100;
let num2 = NaN;
let str1 = "北京";

console.log(Number.isNaN(num1)) //false
console.log(Number.isNaN(num2)) //true
console.log(Number.isNaN(str1)) //false
```

### Number.parseInt()

```
console.log(Number.parseInt(12)) //12
console.log(Number.parseInt(12.34)) //12
console.log(Number.parseInt("123")) //123
console.log(Number.parseInt("12.34")) //12
console.log(Number.parseInt("12.34.56")) //12
console.log(Number.parseInt("北京")) //NaN
console.log(Number.parseInt("1个苹果")) //1
console.log(Number.parseInt("1个23")) //1
console.log(Number.parseInt("12abc")) //12
```



```
console.log(Number.parseInt("1000", 10))  //1000
console.log(Number.parseInt("1000", 2))   //8
console.log(Number.parseInt(Infinity, 19)) //18
console.log(Number.parseInt(Math.random() * 10))//6
//用到二进制
//"Infinity"
      //a 10 b 11 c 12 d 13 e 14 f 15 g 16 h 17 i 18  十六进制

      //0000 0
      //0001 1
      //0010 2
      //0011 3
      //0100 4
      //0101 5
      //0110 6
      //0111 7
      //1000 8
```



### Number.parseFloat(string)

```js
/*
    Number.parseFloat(string) 方法可以把一个字符串解析成浮点数。
    给定值被解析成浮点数，如果无法被解析成浮点数，则返回NaN
*/
let num1 = Number.parseFloat(12.34)
let num2 = Number.parseFloat("2.54")
let num3 = Number.parseFloat("3.3.3")
let num4 = Number.parseFloat("%%") //NaN  无法解析成浮点数
console.log(num1) //12.34
console.log(num2) //2.54
console.log(num3) //3.3
console.log(num4) //NaN
```

### Number.prototype.toFixed()

```js
//tofixed用法,tofixed是Number工厂的一个属性
//取小数点后数字的个数
let num1 = 66.66;
let num2 = 12.6678979;
let num3 = "88.88"

//Object.tofixed(a)  a是你要取多少位小数
console.log(num1.toFixed(1));//取一位小数
console.log(num2.toFixed(3));//取3位小数
//console.log(num3.toFixed(2)); //因为Number只能用于数字不能用于字符串
                              //字符串Object也没有toFixed这个方法
                              //所以会显示错误not function
//Number.prototype.toFixed() 方法是这样的,为什么引用的时候不用加prototype呢? 答:周期  可跳过或者了解
```

### Math

```js
let num = -0.6;
console.log(Math.abs(num)); //取绝对值   0.6
console.log(Math.floor(num)); //向下取整，向小取    -1
console.log(Math.ceil(num)); //向上取整，向大取    -0
console.log(Math.round(num)); //四舍五入取整（正数四舍五入，负数五舍六入）   -1
console.log(Math.random()); //生成0-1之间的随机数   0.09446930011662502
//Math.max找到数组其中的最大值
let a = 2;
      let b = 1;
      let c = 3;
      //如何找到数组的最大值?
      console.log(Math.max(a, b, c)) //3
```



## 小结

### Array

#### 定时器

setTimeout 页面会在time毫秒后执行一次callback

```JavaScript
setTimeout(callback, time);
```

clearTimeout 页面会清除定时器timer

```JavaScript
clearTimeout(timer)
```

setInterval 页面会每隔time毫秒执行一次callback

```JavaScript
setInterval(callback, time);
```

clearInterval 页面会清除定时器timer

```JavaScript
clearInterval(timer)
```

#### 数组(Array)

```JavaScript
let arr = [];
let arr = new Array();  //参数表达的是数组的长度
let arr = Array.of();   //直接书写真正的数组
```

#### length属性

特别特殊: 可getter**可setter**

#### 检测数组

+ Array.isArray(temp) 返回一个布尔类型
+ *Array.from()*

#### 栈方法

+ **push()
+ **pop()

#### 队列方法

+ **shift()
+ **unshift()

#### 重排序方法

+ reverse()
+ **sort()

#### 操作方法

+ concat()

```JavaScript
let arr,arr2,arr3
let newArr = arr1.concat(arr2, arr3)
let newArr = [...arr1, ...arr2, ...arr3]
```

+ slice() 找到子数组的方法
+ **splice(start, deleteCount, item1, item2, ...)

#### 位置方法

+ indexOf(val)  
+ lastIndexOf(val)  

#### 迭代方法

+ **forEach(callback(element, index, arr)) 规定return undefined
+ every() 判断整个数组是否满足某个条件 满足true && 
+ some() 判断整个数组中有满足该条件的 有就true ||  
+ filter() 类似一个过滤器,返回一个过滤后的内容 
+ **map()  对每个数组元素执行回调函数且返回一个新的数组
+ *for...of* 遍历迭代器(能被for...of迭代的实例)
  + Array
  + String
  + Set
  + Map
  + Arguments
  + *keys()*
  + *values()*
  + *entitys()*

#### 归并方法  

+ flat()
+ reduce()  
+ reduceRight()  

#### 扩展运算符

三个点 **...**

#### 集合(Set)

+ 确定性
+ 无序性
+ 互异性

### String

其实我们可以把String看成是一个简单的数组

#### 算法基础

算法最基础的内容是三点

+ 查询
+ 排序
+ 去重

#### 冒泡排序

#### 交换变量

#### 集合 Set(ES6)

+ 确定性
+ 互异性  



#### 属性

+ length String的length才是真正的length属性,一般情况下length属性是只可读不可写的

#### 方法

#### 查询方法

+ charAt(index) str[4] <===> str.charAt(4)
+ charCodeAt(index) 根据下标查询对应位置的字符的Unicode码点 a -> 97
+ String.fromCharCode(unicode) 根据Unicode查询对应的字符

#### 匹配方法

+ **indexOf()   
  + 非贪婪(贪心)算法/懒汉模式 
  + 查找到第一个满足条件的子串 
  + 查找的位置是头部的位置 
  + 如果查找不到的话 那么返回是的-1
+ lastIndexOf()
  + 从右向左
+ *startsWith()*
+ *endsWith()*

#### 截取方法

+ substr(已废弃)
+ substring(start, end) 
  + 支持数字颠倒
  + **包头不包尾**
+ slice(start, end) 
  + 支持负数,即从右到左计算
  + **包头不包尾**
+ **trim() 清除两边空格
  + trimLeft
  + trimRight

#### 修改及转换方法

+ toUpperCase() 转大写
+ toLowerCase() 转小写
+ **split(temp) 根据temp截取字符串为数组
+ **Array.prototype.join()



## 方法小结

### 字符串

#### String.prototype.indexOf

#### String.prototype.lastIndexOf

查找第一个满足条件的下标

#### String.prototype.slice

#### String.prototype.substring

- 字符串截取 子串
- 通通都不会改变源数据

#### String.prototype.split

#### String.prototype.trim

清空字符左右两边的空白

#### String.fromCharCode()

拿到字符串的一个 UTF-16 的编码号

#### String.prototype.charCodeAt()

根据一个 UTF-16 的编码号生成一个字符

#### String.prototype.toString()

将数据类型 从 String -> String

#### Array.prototype.reverse() 

数组反转 头变尾 尾变头

#### Array.prototype.join

- 字符串切割数组
- 数组粘合成字符串









