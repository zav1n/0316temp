# add面试题

```js
//1.先执行add(1, 2, 3) => inner同时闭包存储 1,2,3 inner(4, 5)(6, 7)
//2.再执行inner(4, 5) => add(1,2,3,4,5)
//3.再执行add(1,2,3,4,5) => inner 同时闭包更新为 1,2,3,4,5 inner(6, 7)
//4.再执行inner(6, 7) => add(1, 2, 3, 4, 5, 6, 7)
//5.再执行add(1, 2, 3, 4, 5, 6, 7) => inner 同时闭包更新为 1, 2, 3, 4, 5, 6, 7 console.log(inner)
//6.在页面即将打印的瞬间 他会自动调用toString(),我决定改写toString 对闭包外参数进行叠加 输出结果
let add = (...outerArgs) => {
    let inner = (...innerArgs) => add(...outerArgs, ...innerArgs)
    inner.toString = () => outerArgs.reduce((acc, cur) => acc + cur)
    return inner
}
    console.log(add(1, 2, 3)(4, 5)(6, 7))
//[Function: inner] { toString: [Function] }

/*---------------------------------------*/
function add2(...outerArgs) {
		function inner(...innerArgs) {
    return add2(...outerArgs, ...innerArgs)
    }
    inner.toString = function () {
        // 参数的处理
        let result = 0;
        for (let i = 0; i < outerArgs.length; i++) {
            result += outerArgs[i]
        }
        return result
    }
    return inner
}
console.log(add2(1, 2, 3)(4, 5)(6, 7))
//[Function: inner] { toString: [Function] }
/**--------------------------------*/
function add1(...outerArgs) {
    inner.toString = function () {
        let result = 0;
        for (let i = 0; i < outerArgs.length; i++) {
            result += outerArgs[i]
        }
        return result
    }
    function inner(...innerArgs) {
        return add1(...outerArgs, ...innerArgs)
    }
    return inner
}
console.log(add1(1, 2, 3)(4, 5)(6, 7))
//[Function: inner] { toString: [Function] }

```
# 冒泡排序

## 1.快速排序

```js
let arr = [2, 9, 5, 6, 4, 1, 8, 3, 7]
function quickSort(arr){
    if (arr.length <= 1) return arr//最后的结束语句
    let flag = arr.shift()  //取中间值
    let left=[],right=[];//来存左右边的值
    for(let i =0;i<arr.length;i++){
        if(arr[i]<flag){  //如果小于flag就往左边放,否则往右边放
            left.push(arr[i])
        }else{
            right.push(arr[i])
        }
    }
    //return [左边 flag  右边]
    return[...quickSort(left),flag,...quickSort(right)]
}
console.log(quickSort(arr));
```

## 2.双重for排序

```js
let arr = [2, 9, 5, 6, 4, 1, 8, 3, 7]
function bubbleSort(arr) {
    for (let i = 0; i < arr.length - 1; i++) {
        for (let j = 0; j < arr.length - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]
            }
        }
    }
}
bubbleSort(arr)
console.log(arr);
//不能直接写在控制台,因为排序改变了原来的数组
```

+ ### for升序降序

  ```js
    /**
     * @param arr {Array} 待排序的数组
     * @param sort {String} 排序的方法 "asc" 使用升序排列 "desc" 使用降序排列
     */
    function bubbleSort2(arr, sort) {
      for (let i = 0; i < arr.length - 1; i++) {
        //比较的次
        for (let j = 0; j < arr.length - 1 - i; j++) {
          // 0-4
          let temp = arr[j] - arr[j + 1]
          //前者大于后者 且 排序规则是升序排列的时候 就交换位置
          //前端小于后者 且 排序规则是降序拍的的时候 就交换位置
          if ((temp > 0 && sort === "asc") || (temp < 0 && sort === "desc")) {
            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]
          }
        }
      }
      return arr
    }
    let arr = [2, 4, 5, 1, 3]
    console.log(bubbleSort2(arr, "asc")) //[1, 2, 3, 4, 5]
    console.log(bubbleSort2(arr, "desc")) //[5, 4, 3, 2, 1]
    // 稍微 说一下
    // 传统去重 是不是可以考虑
    // 先排序再去重 ? ?
  
    // console.log(bubbleSort(arr))
  
    let a = -5;
    cosnole.log(Math.abs(a) === a) //就是非负数 |5| = 5  |-5| = 5
  ```

## 3.sort方法

```js
var numbers = [4, 2, 5, 1, 3]; 
numbers.sort((a, b) => a - b); 
console.log(numbers);j's
// [1, 2, 3, 4, 5]
```



# 爬阶梯

```js
function fn(n) {
if (n === 1 || n === 2) {
    return n
} else {
    return fn(n - 1) + fn(n - 2)
}
}
console.log(fn(3))//3
console.log(fn(4))//5
console.log(fn(5))//8
console.log(fn(10))//89
```



```js
//问题 我有个N个阶梯 我每次迈出的步子 可以是一个阶梯 也可以是两个阶梯
//请问 爬楼的方法 有多少种?
//爬阶梯利用了斐波那契的方法

//解题思路
//若爬10层,则
//fn(10) = fn(9) + fn(8)
//fn(9) = fn(8) + fn(7)
//fn(8) = fn(7) + fn(6)
//...
//fn(3) = fn(2) + fn(1)
//fn(2) = 2 
//fn(1) = 1
//因为走一步和两步,只有一种或者两种情况,所以第一步和第二步各是1 和 2 ,所以for的判断要从3开始

   function ladder1(m) {       //一定要有形参数
   if (m === 1 || m === 2) return m
   let r1 = 1
   let r2 = 2
   let result;
   for (let i = 3; i <= m; i++) {  //i从3开始,因为前面的第1步和第2步的走法只有1种或者2种 
       result = r1 + r2
       r1 = r2
       r2 = result    //这3各条件的顺序不能乱,要不然就不是本题意思
   }
   return result
   }
   console.log(ladder1(3));
   console.log(ladder1(4));
   console.log(ladder1(5));
   console.log(ladder1(6));

console.log("----------最简便的写法----------------");

function ladder2(n) {
    if (n === 1 || n === 2) {
        return n
    } else {
        return ladder2(n - 1) + ladder2(n - 2)
        //注意!!是函数里面的fn(n-1)和fn(n-2),而不是n-1和n-2
    }
}
console.log(ladder2(3));
console.log(ladder2(4));
console.log(ladder2(5));
console.log(ladder2(6));
```

# 数组扁平化

## 1.for方法

+ ### 一维数组扁平化

```
// let arr = [1, [2, [3, 3], 2], 1]
let arr = [1, 2, [2, 2], 1]
//[1, 2, 3, 3, 2, 1]
// let newArr = arr.flat(Infinity); //[1, 2, [], 2, 1]
// console.log(newArr)
function flatArr(arr) {
  let newArr = [];
  //判断每个元素是不是数组
  for (let i = 0; i < arr.length; i++) {
    if (Object.prototype.toString.call(arr[i]) === "[object Array]") {
      newArr = [...newArr, ...arr[i]]
    } else {
      newArr.push(arr[i])
    }
  }
  //如果是数组就 拆开添加
  //如果是元素 就直接添加
  return newArr;
}
console.log(flatArr(arr))
```



+ ### 多维数组扁平化

```js
let arr = [1, -1, [[2, 0], 5, [3]], 5]
function flatArr(a) {   //一定要有形参!要不然会显示undefined
    let newArr = []  //定义一个空的数组来接新的数组
    for (let i = 0; i < arr.length; i++) {
        if (Object.prototype.toString.call(arr[i]) === "[object Array]") {
            newArr = [...newArr, ...arr[i]]
        } else {
            newArr.push(arr[i])
        }
    }
    return newArr  //一定要return newArr  要不然会显示undefined
}
console.log(flatArr(arr))
```

## 2.flat方法

```js
//使用 Infinity，可展开任意深度的嵌套数组
var arr4 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]];
arr4.flat(Infinity);
// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```



# 递归

```js
// function fn() {
//   fn()
// }

// 1. 自己调用自己
// 2. 因为自己调用自己会出现无限死循环 所以还需要设置一个停止条件
// 3. 递归永远是树形结构 -> 递归树
// 4. 最先调用的函数 最后执行完毕 最后调用的函数 最先执行完毕
// 阶乘
// 5! = 5 * 4 * 3 * 2 * 1  = fn(5) => fn(4) * 5
// 4! =     4 * 3 * 2 * 1  = fn(4) => fn(3) * 4
// 3! =         3 * 2 * 1  = fn(3) => fn(2) * 3
// 2! =             2 * 1  = fn(2) => fn(1) * 2
// 1! =                 1  = fn(1) => 1
// fn(n) = fn(n - 1) * n
// n! => fn(n)
// 5! => fn(5)  4! => fn(4)  3! => fn(3)  2! => fn(2)  1! => fn(1)

function fn(n) {
  debugger
  if (n === 1) {
    return 1
  } else {
    return n * fn(n - 1)
  }
}

//fn(5) 开启一个栈内存
//fn(4) 开启一个栈内存
//fn(3) 开启一个栈内存
//fn(2) 开启一个栈内存 
//fn(1) 开启一个栈内存 return 1
console.log(fn(4))  //24
// console.log(fn(5))
// console.log(fn(6))
```
# 邮箱正则

```js
let str1 = "123456789@qq.com"
let str2 = "123456789@163.com"
let str3 = "123456789@163.com.cn"
let str4 = "123456789@163.edu"
let str5 = "123456789@163.gov"
let str6 = "123456789@163.gov.jp"
let str7 = "hu_p@163.com.cn"
let str8 = "hu_p@163.com"

let reg = /^\w+@\w+[.]\w{2,4}([.]\w{2,4})?$/

console.log(reg.test(str1))
console.log(reg.test(str2))
console.log(reg.test(str3))
console.log(reg.test(str4))
console.log(reg.test(str5))
console.log(reg.test(str6))
console.log(reg.test(str7))
console.log(reg.test(str8))
```

# 对象强转数字

```js
//1. 字符串的key,永远是string
//2. 不是字符串 就应该隐式转换成字符串
//3. 强转字符串方法 toString()
//如果 无法调用 toString() 转而调用更原始的方法 valueOf()
//4. 对象也会调用Object.prototype.toString()
//5. Object.prototype.toString() => "[object Object]"
let a = {};
let b = {
  "name": "张三"
}
let c = {
  "name": "李四"
}
a[b] = 123; //a.{"name": "张三"} =>a.{"name": "张三"}.toString() => a."[object Object]"
a[c] = 456; ///a.{"name": "李四"} => a.{"name": "李四"}.toString() => a."[object Object]"

console.log(a[b]) //456
console.log(a[c]) //456
```
# a同时等于1,2,3

```js
//(a== 1 && a ==2 && a==3)可能为true吗?
let a = {
  num: 1,
  valueOf: function () {
    return this.num++
  },
  toString: function () {
    return this.num++
  }
}
console.log(a == 1 && a == 2 && a == 3) //true
```

# 修改样式

```js
<div id="box"></div>
<script>
    let box = document.getElementById("box")
        //下面的写法是否可以修改元素的样式，如果不可以是为什么？
        //第一种方案
    let s1 = box.style;
    console.log(s1); //返回0
    s1.color = 'blue';
    // //第二种方案
    let s2 = box.style.color;
    console.log(s2); //返回empty string
    s2 = 'red';
    // //=>哪种方式可以实现，不能实现是因为啥？
    //都不可以,s1返回0,s2返回empty string
</script>
```
# 判断类型typeOf

```js
console.log(typeof 37 === 'number');
console.log(typeof(42) === 'number');
console.log(typeof NaN === 'number');
console.log(typeof Math.LN2 === 'number');
console.log(typeof Infinity === 'number');
console.log(typeof Number(1) === 'number');
console.log(typeof 42n === 'bigint');
//都输出为true
```

```js
console.log(typeof 1);//number
console.log(typeof (typeof 1) === 'string');//第一个typeof 1里面显示的是number而不是数字，再一次typeof就变成字符串了
console.log(typeof String(1) === 'string'); // String 将任意值转换为字符串，比 toString 更安全
//都是true
```

```js
console.log(typeof Boolean(1) === 'boolean');
console.log(typeof !!(1) === 'boolean');
//都是true
```

```js
console.log(typeof Symbol() === 'symbol');//true
console.log(typeof Symbol('foo') === 'symbol');//true
console.log(Symbol.iterator === 'symbol');//false

console.log(typeof {a: 1} === 'object');//true
console.log(typeof [1, 2, 4] === 'object');//true

console.log(typeof new Date() === 'object');// 注意!Date是对象   //true
console.log(typeof /regex/ === 'object');//true
```

```js
// 下面的例子令人迷惑，非常危险，没有用处。避免使用它们。
//只要是new了就是相当于生成一个对象,我是这么理解的
console.log(typeof new Boolean(true) === 'object');
console.log(typeof new Number(1) === 'object');
console.log(typeof new String('abc') === 'object');
```

```js
// 函数  使用class  function就是函数
typeof function() {} === 'function';
typeof class C {} === 'function'
typeof Math.sin === 'function'; //正弦啊~~正弦在数学中本来就叫做函数,所以就是函数啊
```

# NaN的判断

```js
var str = "abc123"
var num = parseInt(str)
if (num == NaN) {
  console.log(NaN)             //虽然num是NaN,但是会报错,报NaN,所以执行不了 ===也没用,要用Nmunber.in
} else if (num == 123) {
  console.log(123)           //字符串不等于数字,所以不执行
} else if (typeof num == "number") {
  console.log("number")     //考点:typeof   操作符返回一个字符串，表示未经计算的操作数的类型。
} else {
  console.log("str")
}
//输出 number  typeof num == "number"条件成立
```

# 立即执行函数解决面试题6

```js
for (var i = 0; i < 5; i++) {
  (function (j) {
    setTimeout(() => {
      console.log(j)
    }, 0);
  }(i))
}
//0 1 2 3 4
//需要重温视频备注一下
```

# 程序分析题

```js
let n = [10, 20];
let m = n;
let x = m;
m[0] = 100;
x = [30, 40];
x[0] = 200;
m = x;
m[1] = 300;
n[2] = 400;
console.log(n);//[ 100, 20, 400 ]
console.log(m);//[ 200, 300 ]
console.log(x);//[ 200, 300 ]
```
# 经典面试题

## 1.

```js
let num = 1;
let obj = {
  name: "张三"
}

num2 = num
obj2 = obj

console.log(num) //1
console.log(num2) //1
console.log(obj.name) //"张三"
console.log(obj2.name) //"张三"

//浅复制
// 只有复合数据类型才有深浅复制
// 引用数据类型 "=" 浅复制
obj2.name = "李四"
num2 = 2;

console.log(num) //1
console.log(num2) //2
console.log(obj.name) //"李四"
console.log(obj2.name) //"李四"
```
## 2.

```js
var a = 11;
function show() {
   console.log(a) //undefined
   var a = 12;
 }
show() //undefined
```
## 3.

```js
var a = 1;
var b = 2; //10

function show() {
  var a = b = 10;  //b = 10是全局变量,而a仅仅在函数里面被赋值了10并没有被应用全局
  console.log(a) //10局部变量
  console.log(b) //10全局变量
}

show()
console.log(a) //1
console.log(b) //10
```

## 4.

```
let num = 1;
let obj = {
  name: "张三"
}

let num2 = num;
let obj2 = obj;
console.log(num)    // 1
console.log(num2)   // 1
console.log(obj.name)  // 张三
console.log(obj2.name)  // 张三

num = 2
obj.name = "李四"

console.log(num) //2
console.log(num2) // 1
console.log(obj.name)  //李四
console.log(obj2.name)  //李四 obj2的地址原先是张三,后来地址的张三被改为李四,所以obj2就变成李四
                        //数字的话就要看域
```

## 5.

```js
console.log([] === [])
console.log([] == [])
console.log({} === {})
console.log({} == {})

// 四个得出来的结果是什么?

// 其实类比如以下

let obj = new Object(); //0x111
let obj2 = new Object(); //0x222
let arr = new Array();
let arr2 = new Array();
console.log(obj === obj2)
console.log(obj == obj2)
console.log(arr === arr2)
console.log(arr == arr2)
```

## 6.

```js
let num = 1;
let obj = {name: "张三"}

let num2 = num;
let obj2 = obj;
num = 2

obj = { name: "李四"}

console.log(num) //2
console.log(num2) //1
console.log(obj.name) //李四
console.log(obj2.name) //张三
```

## 7.

```js
//请说出以下输出结果
console.log(parseInt(1.3))//1
console.log(1)      //1
console.log(isNaN(1))   //false
console.log(parseInt("1"))//1
```

## 8.

```js
//下面程序输出的结果
if (isNaN(NaN) == "") {
  console.log("老胡")
 } else {
  console.log("前端")
 }
//前端
```

## 9.

```js
//下面程序输出的结果
let x = [1, 2, 3]
let y = x
let z = [4, 5, 6]
y[0] = 10
y = z
z[1] = 20
x[2] = z = 30 //难点
console.log(x, y, z)

//[ 10, 2, 30 ] [ 4, 20, 6 ] 30
```

## 10.

```js
var a = 0
var b = a
b++
console.log(a)
//0
var o = {}
o.a = 0
var b = o
b.a = 10
console.log(o.a)
//10
//o.a不太懂
```



# 综合面试题

## 1.



```HTML
<div>
    <div>
        <span id="span1">
            <span id="span2">大家好</span>
            <span class="span2">
            我好
                <h3>
                    <span class="span1">你好</span>
                </h3>
            </span>
        </span>
    </div>
</div>
```

A

```css
span#span1 h3 span .span2 {color: red;}
```

B

```css
h3.span1 {color: red;}
```

C

```CSS
h3.span2 span.span1 {color: red;}
```

**D**

```css
span#span1 h3 span.span1 {color: red;}
```



2.

```js
var i = 12;
var sum = i++ + ++i + ++i*2 + i-- + i--;
console.log(sum+" "+i);
13+14*2+15+14+13
```

```
**A**：85 13	 B：84 12  C：83 11 D：85 14
```



3.//如何将arr的数组降序排序

```js
var arr = [25, 111, 18, 12, 92, 5, 15]
```

```js
A.arr.sort()
B.arr.sort(function(a, b) { return a - b })
C.arr.sort(function(a, b) { return b - a })
D.arr.sort(b - a)

//答案 B
arr.sort() //[111,12,15,18,25,5,92]
arr.sort(function(a, b) { return a - b }) //[5,12,15,18,25,92,111]
arr.sort(function(a, b) { return b - a })//[111,92,25,18,15,12,5]
arr.sort(b - a) //报错，b is not defined
```



4.

```js
var arr = [1, 2, 3, 4]
// 执行arr.concat(1,2,3,[1,2,3,],5)后，arr的长度为（）
A:4	B:9	C:11	D:5

//答案 C
//let newArr = arr.concat(1, 2, 3, [1, 2, 3, ], 5)   //[1,2,3,4,1,2,3,1,2,3,5]
//console.log(newArr.length);  // 11

```

5.

```js
// var now = new Date(),设置3天后的时间正确写法（）
// A：now.setDate(now.getDate()+3)
// B：now.setTime(now.getTime()+3)
// C：now.setTime(now.getDate()+3*1000*3600*24)
// D：now.setTime(now.getMILLISECONDS()+3*1000*3600*24)

//不懂
```

6.请实现一个数组的冒泡排序

大概有四种：

1.双重for夹if

2.快速排序

3.flat方法

4.sort方法

5.两边排序，就是有个中立变量，一边在左边判断，一边在右边判断

7.请写出你目前知道的除Vue等企业型框架外其他前端开源框架或者前端调试工具，有什么优缺点

8.请写出你前端编码中你认为比较好的编码规范和代码习惯

+ 常保存，以免宕机或者其他意外
+ 实现好一个功能或者代码块时复制多一份，再到副本继续编写，以免其他功能或者代码块也一同修改，并且可以作为参考
+ 函数封装，不能太多冗余代码，例如定义的属性应该用函数包装再调用。还有常用的函数可以另外创建一个js文件作为工具类调用，提高效率
+ 符合从上往下执行的顺序，有利于代码的查看和修改
+ HTML,CSS,JS，image，iconfont等等要分开文件夹存放，提高工作效率

9.以下下那个plus的方法能使手机旋转至横屏（）猜测是B

```
A：plus.screen.lockOrientation("portrait-primary")
B：plus.screen.lockOrientation("landscape-primary")
C：plus.screen.lockOrientation("landscape-secondary")
D：plus.screen.lockOrientation("portrait-secondary")
```

10，下面哪一个是JQ用来追加到指定元素的末尾的？（D）

```
A insertAfter（）B.append（）C.appendTo()	D.after（）
```

11.在JQ中，想要从DOM中删除所有匹配的元素，下面那一个是正确的？（D）

```
A delete() 	B empty() 	C remove() 	D removeAll()
```

12.下面哪一个不是JQ对象访问的方法？（）应该是B吧

A each(callback)	B size() 	C index(subject)	D after()

13.5+App访问手机存储文件正确的方法为：（A）

A: plus.io.requestFileSystem

B: plus.io.resolveLocalFileSystemURL

C: plus.io.convertLocalFileSystemURL

D: plus.io.convertAbsoluteFileSystem

14.以下获取动态路由{path:‘/user/:id’}中id的值正确的是(A)

A：this.$route.params.id

B：this.route.params.id

C：this.$router.params.id

D：this.router.params.id

15.以下对vue的的双向绑定说法不正确的是(D)

A:采用数据劫持结合发布者,订阅者模式的方式

B:通过Object.defineProperty()来劫持各个属性的setter,getter,在数据变动时发布消息给订阅者,触发相应监听回调

C:MVVM作为数据绑定的入口,整合Observer,Compile和Watcher三者,通过Observer来监听自己的model的数据变化

D:vue是通过基于脏检查机制实现双向绑定

16.以下代码输出结果为(C)

```HTML
    <div id="app">
        {{message.split("").reverse().join("")}}
    </div>
    <script>
        new Vue{{el:'#app',data:{message:'hello'}}}
    </script>
```

A:hello	B:hel	C:olleh	D:llo

17.Vue父子组件间的参数传递时如何做到的?

答:

+ 父组件向子组件传值：

  1）子组件在props中创建一个属性，用来接收父组件传过来的值；

  2）在父组件中注册子组件；

  3）在子组件标签中添加子组件props中创建的属性；

  4）把需要传给子组件的值赋给该属性

+ 子组件向父组件传值：

  1）子组件中需要以某种方式（如点击事件）的方法来触发一个自定义的事件；

  2）将需要传的值作为$emit的第二个参数，该值将作为实参传给响应事件的方法；

  3）在父组件中注册子组件并在子组件标签上绑定自定义事件的监听。