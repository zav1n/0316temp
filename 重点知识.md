# 最后更新 4.20

### 基本数据类型(重点)

+ Number
+ String
+ Boolean
+ Null
+ Undefined
+ Symbol

### 6个false

+ false 0 null NaN undefined "" 

### var 和 let的区别

1. var可以重复定义,let不可以重复定义
2. var有变量声明提升,let没有变量声明提升.(var在同页面还没声明时,可以使用,let在同页面还没声明时候,不可以使用)
3. var不存在暂时性死区TDZ,let存在暂时性死区TDZ(temporal dead zone)
4. var没有块级作用域的概念,但是let有块级作用域

### const 和 var 丶let 的区别

​	1.const的变量值不可变,let和var可变(const其他的特性和let一模一样)

### ASCII对应的A/a/空格

A:65  a:97  空格:32

### 事件委托

2.
e.stop
e.stopPropagfation

### 添加与删除的方法

push  尾部添加N个  
将一个或多个元素添加到数组的末尾，并返回该数组的新长度。
pop  尾部删除一个
从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。
unshift 头部添加
将一个或多个元素添加到数组的开头，并返回该数组的新长度(该方法修改原有数组)。
shift  头部删除
从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。

### 偏函数

function createName(firstName, lastName) {
  return firstName + lastName
}
let wangName = createName.bind(null, "王")
let liName = createName.bind(null, "李")

console.log(wangName("珊珊"))
console.log(wangName("狗蛋"))
console.log(wangName("二小"))

console.log(liName("珊珊"))
console.log(liName("狗蛋"))
console.log(liName("二小"))

### Function的 call & apply & bind

call和apply相同点：
参数第一个都是thisArg(this)，可以立即被调用
call和apply的区别是：
call的第二个this可以有无穷个参数，apply最多只有两个参数且第二个参数形成数组

再扩展！

bind和call和apply的区别
bind仅仅是绑定函数，而apply和call绑定且调用函数

如果要延时调用可以使用bind并且可以在bind里面再次修改或者添加

科里华函数，最难之一，也是面试题之一

#4-11   

### JSON

字符串和JSON对象交换的方法

JSON.parse()  //将字符串串专成对象
JSON.stringify  //将SON转换成对象

### JavaScript有几个作用域

ES5只有两个作用域  全局作用域和函数（局部）作用域
ES6新增一个作用域  块作用域  let/const(变相实现块作用域)
//全局作用域
//函数作用域
//块级作用域

### 同步

同步或者说同步代码,他会马上执行```for```是最典型的同步代码

### 异步

异步代码会延迟执行```事件函数```都是典型的异步代码

### 堆（heap)	(大慢无序)

javascript的基本类型就6种:Undefined、Null、Boolean、NaN、0和String = ""，它们都是直接按值存储在栈中的,内存可以及时得到回收

+ 空间大
  + 堆内存没那么重要(所以内存大)
+ 速度慢
+ 无序

### 栈（stack)	(小快有序)

引用类型的数据的地址指针是存储于栈中的，当我们想要访问引用类型的值的时候，需要先从栈中获得对象的地址指针，然后，在通过地址指针找到堆中的所需要的数据。

+ 空间小
  + 栈内存比较重要(所以内存小)
+ 速度快
+ 有序

1.是所有作用域的执行环境
2.存储所有变量的key
3.存储所有基本数据类型的value

![img](https://images2018.cnblogs.com/blog/1402663/201808/1402663-20180802132101478-2092833591.png)

### 闭包概念

闭包概念：形成一个[不被销毁]的[私有的作用域]
闭包作用：保存变量[不被销毁]  保护变量[私有作用域]
闭包形式：函数嵌套函数，且返回一个堆内存

函数嵌套函数不一定是闭包

+ 内部闭包

```js
//内部闭包
function outer() {
  let a = 1;
  function inner() {
    console.log(a)
    a = a + 1;
  }
  inner()
  inner()
  inner()
}
outer() //1,2,3
outer() //1,2,3
```

+ 外部闭包

  ```js
  function outer() {
    //定义一个局部变量
    let a = 1;
    //定义一个内部函数
    function inner() {
      console.log(a)
      a = a + 1
    }
    //返回的是一个内部的函数体
    return inner
  }
  
  //1. 开辟一个outer作用域
  //2. 将inner函数体 返回给 add
  //局部变量 在函数执行完毕之后(触碰到大括号 或者 触碰到return)的时候 该作用域都会销毁
  let add = outer(); //inner
  
  add() //inner()
  add()
  add()
  ```

+ 外部闭包2

  ```js
  //全局变量 永远不会销毁 局部变量 在return或者大括号之后 总会被销毁
  //f_outer堆内存 f_add 永远不会被销毁
  //4. 由于outter函数开启的这一次作用域的局部函数 inner没有被销毁 为了保证inner函数的存在,所inner的宿主 也就是这一次的outer作用域 也永远存在
  function outer() {
    //5. 由于outer作用域永远存在 所以a作为一个局部变量 也不会被销毁 得到了永生(也就是全局变量的效果)
    let a = 1;
    function inner() {
      console.log(a)
      a = a + 1
    }
    //3. 由于inner函数(0x222)被全局变量所引用 所以装着inner函数的宿主outer函数的那次作用域也永远存在不会被销毁
    return inner
  }
  //1.因为add是全局变量 所以add永远存在
  //2. 因为add永远存在 所以add接收的返回值也就是inner 也永远存在
  let add = outer(); //inner
  //6.所以每次调用add函数 就相当于是调用inner函数 且使用的a 永永远远是同一个a
  add() //inner() 1
  add() //2
  add() //3
  
  // add -> inner -> outer作用域 -> a永远不会被重新初始化
  ```

  

### 实参 , 形参 , 不定参函数

形参能多于实参

而实参不可以多于形参 , 当实参数量少于形参的时候 默认值为 undefined

```
 function show(name, age, job, year = 0) {
    console.log(arguments)
   }
   //当实参数量少于形参的时候 默认值为 undefined
   show("张三", 20, "信息工程")
   show("李四", 30, "法学", 8)
   show()


```

### arguments

   //每当函数被调用的时候 函数总是会自带一个aruguments对象 他是Arguments类型

   //这个Arguments对象会包含 这个函数作用域中被传入的实参

   //Aruments 和 HTMLCollection 都是 类数组对象

   //array like object 长得像数组一样的东西 但是不是数组

   //都有下标 都有length

+ ```
  function sum() {
      let arr = arguments; //[3, 6, 9]
      let result = 0;
      for (let i = 0; i < arr.length; i++) {
      result += arr[i]
      }
  return result
  }
  console.log(sum(1, 2)) //3
  console.log(sum(3, 6, 9)) //18
  console.log(sum(2, 3, 4, 5)) //14
  console.log(sum(2, 3, 4, 5, 10)) //24
  ```

  



* 注意,箭头函数里面不能直接用arguments这个单词

要在  箭头函数的小括号加...arr

例如   

```javascript
let sum = (...arr) => {
    //rest扩展符 永远会将所有的剩余的参数全部都收集到这个形参中 且是真数组
    let result = 0;
    console.log(arr)
    for (let i = 0; i < arr.length; i++) {
     result += arr[i]    }
    return result   }
   console.log(sum(1, 2)) //3
   console.log(sum(1, 2, 3)) //18
   console.log(sum(1, 2, 3, 4)) //14
   console.log(sum(1, 2, 3, 4, 5)) //24
```



###  在函数  求最大的值 

+ 写法一:

```
let arr = [4, 8, 2, 10]
function maxNumber(*arr*) {
let max = arr[0]; //确认这个数组的第一号位置是最大的数字
    for (let i = 1; i < arr.length; i++) {
        //如果新上擂的兄弟 比现在最大的这个数字还要大 那么他就更大的一个数字
        if (max < arr[i]) {
        // 数组中这个元素大于之前所有数字
        max = arr[i]
        }
    }
return max
}
console.log(maxNumber(arr))
```



+ 写法二 :

  ```
  let arr = [4, 8, 2, 10]
  function maxNumber(arr) {
      return Math.max(...arr) //Math.max(4, 8, 2, 10)
  }
  let maxNumber2 = arr => Math.max(...arr)
     console.log(maxNumber(arr))
  ```

### addEventListener的click和onclick的区别

#### onclick

优点： 
\- 简洁 
\- 处理事件的this关键字指向当前元素 
缺点： 
\- 不能对事件捕获或事件冒泡进行控制，只能使用事件冒泡，无法切换成事件捕获 
\- 一次只能对一个元素绑定一个事件处理程序，当使用window.onload属性时，会覆盖采用相同方法所绑定的事件代码

#### addEventListener

可以支持事件处理的捕获阶段，也可以支持时间处理的冒泡阶段，两个阶段都是通过addEventListener最后一个参数设置为false(默认值，表示事件冒泡)或者true(表示事件捕获)来切换 
\- 事件处理 this与onclick一样 
\- 事件处理函数中，event对象总是作为第一个可用参数 
\- 你可以为某个元素绑定多个事件而不会覆盖之前绑定的处理程序 （按照顺序执行） 
缺点： 
\- IE8以下不支持