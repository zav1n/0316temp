# 最后更新 4.20

### 基本数据类型(重点)

+ Number
+ String
+ Boolean
+ Null
+ Undefined
+ Symbol

### 6个false

+ false 0 null NaN undefined "" 

### var 和 let的区别

1. var可以重复定义,let不可以重复定义
2. var有变量声明提升,let没有变量声明提升.(var在同页面还没声明时,可以使用,let在同页面还没声明时候,不可以使用)
3. var不存在暂时性死区TDZ,let存在暂时性死区TDZ(temporal dead zone)
4. var没有块级作用域的概念,但是let有块级作用域

### const 和 var 丶let 的区别

​	1.const的变量值不可变,let和var可变(const其他的特性和let一模一样)

### ASCII对应的A/a/空格

A:65  a:97  空格:32

### 事件委托

+ 事件有哪两种形式? 普通事件/绑定事件

+ 加: onxxxxx(普通事件) addEventListener(绑定)

+ 绑定事件和普通事件的区别 普通事件只能有一个/绑定事件有多个

+ 删 = null (普通事件) removeEventListener(绑定)

+ 事件流

  + 事件冒泡
  + 事件捕获

+ 事件源

+ 阻止事件向后运行

+ 阻止默认事件发生

+ 事件委托

  - 事件委托: 将子元素的事件触发 委托给 父元素来管理

    1. 极大的降低了事件函数的个数

    2. 新增的节点自动也会有相应的行为



### 添加与删除的方法

push  尾部添加N个  
将一个或多个元素添加到数组的末尾，并返回该数组的新长度。
pop  尾部删除一个
从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。
unshift 头部添加
将一个或多个元素添加到数组的开头，并返回该数组的新长度(该方法修改原有数组)。
shift  头部删除
从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。

### 偏函数

function createName(firstName, lastName) {
  return firstName + lastName
}
let wangName = createName.bind(null, "王")
let liName = createName.bind(null, "李")

console.log(wangName("珊珊"))
console.log(wangName("狗蛋"))
console.log(wangName("二小"))

console.log(liName("珊珊"))
console.log(liName("狗蛋"))
console.log(liName("二小"))

### Function的 call & apply & bind

call和apply相同点：
参数第一个都是thisArg(this)，可以立即被调用
call和apply的区别是：
call的第二个this可以有无穷个参数，apply最多只有两个参数且第二个参数形成数组

再扩展！

bind和call和apply的区别
bind仅仅是绑定函数，而apply和call绑定且调用函数

如果要延时调用可以使用bind并且可以在bind里面再次修改或者添加

科里华函数，最难之一，也是面试题之一

  

### JSON

字符串和JSON对象交换的方法

JSON.parse()  //将字符串串专成对象
JSON.stringify  //将SON转换成对象

### JavaScript有几个作用域

ES5只有两个作用域  全局作用域和函数（局部）作用域
ES6新增一个作用域  块作用域  let/const(变相实现块作用域)
//全局作用域
//函数作用域
//块级作用域

### 同步

同步或者说同步代码,他会马上执行```for```是最典型的同步代码

### 异步

异步代码会延迟执行```事件函数```都是典型的异步代码

### 堆（heap)	(大慢无序)

javascript的基本类型就6种:Undefined、Null、Boolean、NaN、0和String = ""，它们都是直接按值存储在栈中的,内存可以及时得到回收

+ 空间大
  + 堆内存没那么重要(所以内存大)
+ 速度慢
+ 无序

### 栈（stack)	(小快有序)

引用类型的数据的地址指针是存储于栈中的，当我们想要访问引用类型的值的时候，需要先从栈中获得对象的地址指针，然后，在通过地址指针找到堆中的所需要的数据。

+ 空间小
  + 栈内存比较重要(所以内存小)
+ 速度快
+ 有序

1.是所有作用域的执行环境
2.存储所有变量的key
3.存储所有基本数据类型的value

![img](https://images2018.cnblogs.com/blog/1402663/201808/1402663-20180802132101478-2092833591.png)

### 闭包概念

闭包概念：形成一个[不被销毁]的[私有的作用域]
闭包作用：保存变量[不被销毁]  保护变量[私有作用域]
闭包形式：函数嵌套函数，且返回一个堆内存

函数嵌套函数不一定是闭包

+ 内部闭包

```js
//内部闭包
function outer() {
  let a = 1;
  function inner() {
    console.log(a)
    a = a + 1;
  }
  inner()
  inner()
  inner()
}
outer() //1,2,3
outer() //1,2,3
```

+ 外部闭包

  ```js
  function outer() {
    //定义一个局部变量
    let a = 1;
    //定义一个内部函数
    function inner() {
      console.log(a)
      a = a + 1
    }
    //返回的是一个内部的函数体
    return inner
  }
  
  //1. 开辟一个outer作用域
  //2. 将inner函数体 返回给 add
  //局部变量 在函数执行完毕之后(触碰到大括号 或者 触碰到return)的时候 该作用域都会销毁
  let add = outer(); //inner
  
  add() //inner()
  add()
  add()
  ```

+ 外部闭包2

  ```js
  //全局变量 永远不会销毁 局部变量 在return或者大括号之后 总会被销毁
  //f_outer堆内存 f_add 永远不会被销毁
  //4. 由于outter函数开启的这一次作用域的局部函数 inner没有被销毁 为了保证inner函数的存在,所inner的宿主 也就是这一次的outer作用域 也永远存在
  function outer() {
    //5. 由于outer作用域永远存在 所以a作为一个局部变量 也不会被销毁 得到了永生(也就是全局变量的效果)
    let a = 1;
    function inner() {
      console.log(a)
      a = a + 1
    }
    //3. 由于inner函数(0x222)被全局变量所引用 所以装着inner函数的宿主outer函数的那次作用域也永远存在不会被销毁
    return inner
  }
  //1.因为add是全局变量 所以add永远存在
  //2. 因为add永远存在 所以add接收的返回值也就是inner 也永远存在
  let add = outer(); //inner
  //6.所以每次调用add函数 就相当于是调用inner函数 且使用的a 永永远远是同一个a
  add() //inner() 1
  add() //2
  add() //3
  
  // add -> inner -> outer作用域 -> a永远不会被重新初始化
  ```

  

### 实参 , 形参 , 不定参函数

形参能多于实参

而实参不可以多于形参 , 当实参数量少于形参的时候 默认值为 undefined

```
 function show(name, age, job, year = 0) {
    console.log(arguments)
   }
   //当实参数量少于形参的时候 默认值为 undefined
   show("张三", 20, "信息工程")
   show("李四", 30, "法学", 8)
   show()


```

### arguments

   //每当函数被调用的时候 函数总是会自带一个aruguments对象 他是Arguments类型

   //这个Arguments对象会包含 这个函数作用域中被传入的实参

   //Aruments 和 HTMLCollection 都是 类数组对象

   //array like object 长得像数组一样的东西 但是不是数组

   //都有下标 都有length

+ ```
  function sum() {
      let arr = arguments; //[3, 6, 9]
      let result = 0;
      for (let i = 0; i < arr.length; i++) {
      result += arr[i]
      }
  return result
  }
  console.log(sum(1, 2)) //3
  console.log(sum(3, 6, 9)) //18
  console.log(sum(2, 3, 4, 5)) //14
  console.log(sum(2, 3, 4, 5, 10)) //24
  ```

  



* 注意,箭头函数里面不能直接用arguments这个单词

要在  箭头函数的小括号加...arr

例如   

```javascript
let sum = (...arr) => {
    //rest扩展符 永远会将所有的剩余的参数全部都收集到这个形参中 且是真数组
    let result = 0;
    console.log(arr)
    for (let i = 0; i < arr.length; i++) {
     result += arr[i]    }
    return result   }
   console.log(sum(1, 2)) //3
   console.log(sum(1, 2, 3)) //18
   console.log(sum(1, 2, 3, 4)) //14
   console.log(sum(1, 2, 3, 4, 5)) //24
```



###  在函数  求最大的值 

+ 写法一:

```
let arr = [4, 8, 2, 10]
function maxNumber(*arr*) {
let max = arr[0]; //确认这个数组的第一号位置是最大的数字
    for (let i = 1; i < arr.length; i++) {
        //如果新上擂的兄弟 比现在最大的这个数字还要大 那么他就更大的一个数字
        if (max < arr[i]) {
        // 数组中这个元素大于之前所有数字
        max = arr[i]
        }
    }
return max
}
console.log(maxNumber(arr))
```



+ 写法二 :

  ```
  let arr = [4, 8, 2, 10]
  function maxNumber(arr) {
      return Math.max(...arr) //Math.max(4, 8, 2, 10)
  }
  let maxNumber2 = arr => Math.max(...arr)
     console.log(maxNumber(arr))
  ```

### addEventListener、onclick的区别

#### 普通事件和绑定事件

1.普通事件

element.onxxx

2.绑定事件

element.addEventListener()



element.onxxx普通函数的调用 普通函数的参数 永远可以让开发者自行指定

element.addEventListener()事件函数的调用 不允许开发者直接传参 因为事件函数 自带一个事件对象

#### onclick

优点： 
\- 简洁 
\- 处理事件的this关键字指向当前元素 
缺点： 
\- 不能对事件捕获或事件冒泡进行控制，只能使用事件冒泡，无法切换成事件捕获 
\- 一次只能对一个元素绑定一个事件处理程序，当使用window.onload属性时，会覆盖采用相同方法所绑定的事件代码

#### addEventListener

可以支持事件处理的捕获阶段，也可以支持时间处理的冒泡阶段，两个阶段都是通过addEventListener最后一个参数设置为false(默认值，表示事件冒泡)或者true(表示事件捕获)来切换 
\- 事件处理 this与onclick一样 
\- 事件处理函数中，event对象总是作为第一个可用参数 
\- 你可以为某个元素绑定多个事件而不会覆盖之前绑定的处理程序 （按照顺序执行） 
缺点： 
\- IE8以下不支持

### 取消事件绑定

删除监听器 必须事件名称一样 回调函数一样(内存地址一样) 传播方向一样

删除监听器 必须保证 和 增加的时候 三个参数一模一样 才能正确的删除掉该监听器

```
<div id="div1">1</div>
----------------------------------------
let oDiv = document.getElementById("div1");
   //让背景变红色
   oDiv.addEventListener("click", *function* () {
    oDiv.style.backgroundColor = "pink"
   })

   oDiv.removeEventListener("click", *function* () {
    oDiv.style.backgroundColor = "pink"
   })
```

### 如何查看样式并且显示

1.先定义获取div

let oDiv= document.querySelector("div")

2.用getComputedStyle获取div的样式

let oDivCss= getComputedStyle(oDiv)

再输出到控制台可查找样式

console.log(oDivCss)

如果遇到有""包住的样式名字要把 - 后面的首字母变成大写,例如

"border-block-end-style"要变成borderBlockEndStyle

再看看是否获取到边框的样式

console.log(oDivCss.borderBlockEndStyle)

### 文档碎片

HTML DOM 中的 `HTMLCollection` 是即时更新的（live）；当其所包含的文档结构发生改变时，它会自动更新。

不使用动态可以用document.querySelect(".class||#id");

querySelect只能通过document获取

动态不严谨而且要效率

document.querySelectorAll() //获取到所有满足条件的标签

### this

一般情况下,箭头函数可以用this但是他指向的地方是window

```
      <div id="div1">这里有个div</div>
      ------------------------------------
      let oDiv = document.getElementById("div1");
      oDiv.onclick = () => {
        console.log(this) //window
        this.style.backgroundColor = "pink"
      }
```

定时器使用箭头函数时使用this就指向最近的作用域

```
<div id="div1">1</div>
-------------------------------------
let oDiv = document.querySelector("#div1");
      oDiv.onclick = function () {
        setTimeout(() => {
          this.style.backgroundColor = "pink"
          console.log(this)
        }, 1000);
      }
```

当开启一个函数,函数体没有传入实参,使用this时会显示undefined

所以函数要么被对象调用,要么自己传入值

```
let obj = {
"name": "张三",
"age": 18,
"eat": eat	}

function eat() {
console.log(`${this.name}在吃`)	}

obj.eat() //张三在吃
eat() //undefined在吃


```

当一个函数调用对象中的另一个函数时使用this的情况

```
let eat = function () {
    console.log(`${this.name}在吃`)	}

   let obj = {
    "name": "李四",
    "age": 18,
    "eat": {
     name: "张三",
     eat1: eat,
     eat2: eat
    }
   }

   obj.eat.eat1() //undefined在吃
   let eatObj = obj.eat;
   eatObj.eat1();
```

### 阻止事件向后运行

```
let userCapture = true
xxx.addEventListener("click", *function* (*e*) {
    //阻止事件向后运行
    e.stopPropagation()
    // e.cancelBubble = false

    this.style.backgroundColor = "pink"
   }, userCapture)
```

### 事件流

1.很多作用域嵌套叫作用域链(chain)

2.当多个div嵌套,点击最里面的div所有div都会有所反应

[不同的]且带有[嵌套关系]的标签的[同种事件]  多个事件穿成串  且[传播方向一致]   就成为这些事件形成了[事件流]

不同标签 且带有window>document>body>div1>div2>div3的嵌套关系的标签,且发生是同种事件(click)且事件传播方向一直(事件冒泡)满足这三个条件  我们称为是事件流

每个事件不是一个孤立的系统

3.事件流的传播方式有两种

事件冒泡(默认的)   逐步向上传导到window上

事件捕获	先触发window  然后再逐级向下传导到事件源

### Event(e) 事件

+ **事件源**
  + **e.target**
  + e.srcElement IE8以下的浏览器兼容
+ 阻止事件向后执行
  + **e.stopPropagation()** .stop
  + e.cancelBubble = true 阻止事件冒泡
+ 阻止官方默认事件发生
  + **e.preventDefault();** .prevent
  + 在普通事件函数中也可以使用 return false

### focus

当输入框输入数值的时候,另一个p标签文本会实时显示输入框输入的数值



```
<input type="text">
<p id="testP"></p>
----------------------------------
let oInput = document.getElementsByTagName("input")[0]
let oP = document.querySelector("#testP")

oInput.addEventListener("input", function () {
    oP.innerHTML = this.value
    if (this.value.length >= 6) {
    oInput.focus()
    }
})
```

定义input输入框时要给[0]

### 函数防抖和节流

函数防抖和节流的区别：节流就像CD，除了CD的就是防抖

节流：一个事件在一段时间内（300-500ms）内被触发，但绑定的内容在期间会执行一次

函数防抖和节流的应用场景有哪些

防抖：应用文本框

节流：按键/按钮

函数防抖和节流的核心是闭包和定时器

try...catch..finally ，那一段不执行？catch可以不用执行，可以手写报错信息，

有try必有catch

finally可以去掉吗？